# 99클럽 코테 스터디 1일차 TIL + x만큼 간격이 있는 n 개의 숫자

### x만큼 간격이 있는 n 개의 숫자


#### 문제 요지
- x부터 시작해 x씩 증가하는 값(x * i)을 최대 n의 크기만큼 배열에 넣기
- x(-10000000 <= x <=10000000)와 n(n <= 1000)의 범위 체크
- x와 n의 값을 계산 하였을 때 int 형의 계산 범위가 넘기 때문에 Long 변환 해주는 것이 핵심


#### 문제 풀이

##### 1차 시도
- answer[i] = (long) (x * (i + 1)); 계산 방식 이용 

##### 문제점
- (x * (i + 1)) 괄호 안에서 x와 i의 값이 int 형
- 만약 x의 값이 최대 값이고, i의 값이 n의 최대 값이라면 계산 하였을 때 나오는 값이 int 형의 계산 범위 초과

##### 해결방안
- answer[i] = (long) x * (i + 1); 계산 방식 이용
- (long) x 의 값이 long 타입이 되어서 long 타입과 int 타입을 곱하면 리턴 값으로 long 타입이 반환됨

<br>

## 공부 내용 정리

### 자료형
|정수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|
|------|---|---|
|byte|1바이트|-128 ~ 127|
|short|2바이트|-32786 ~ 32767|
|int|4바이트|-2147483648 ~ 2147483647|
|long|8바이트|-9223372036854775808 ~ 9223372036854775807|

<br>

### 타입별 크기 순서
byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)

<br>

### 자동타입 변환
- 작은 크기 타입을 큰 크기 타입으로 변환할 때 (큰 크기 타입 = 작은 크기 타입)

#### 예제1
int intVal = 20;

double doubleVal = intVal; 

결과 값 : 20.0

<br>

### 강제타입 변환(Casting)
- 큰 크기 타입을 작은 크기 타입으로 변환 할 때(작은 크기 타입 = (작은 크기 타입)큰 크기 타입)
- 강제로 타입의 byte를 잘라서 저장하기 때문에 **값의 손실이 일어나지 않도록** 주의 필요

#### 예제1

double doubleVal = 3.14;

int intVal = (int)doubleVal;

결과 값 : 3

<br>

### 연산식에서 자동 타입 변환
- 서로 다른 타입의 연산자가 있을 경우 **크기가 큰 타입**으로 **자동 타입 변환**된 후 연산을 수행
- 연산 시 자동 타입 변환
    - 정수와 실수 연산 = 실수형 타입(double)
    - 정수와 정수 연산 = int 타입
    - 실수와 실수 연산 = double 타입
    - 큰타입과 작은 타입 연산 = 큰타입 


<br>
<br>
#99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
