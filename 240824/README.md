# 99클럽 코테 스터디 34일차 TIL + 타겟 넘버 문제 풀이

### 타겟 넘버

주어진 음이 아닌 정수 배열 `numbers`와 목표 값 `target`을 가지고, 숫자들의 순서를 유지한 채 더하거나 빼서 `target`을 만들 수 있는 경우의 수를 구하는 문제입니다. 이 문제는 DFS(깊이 우선 탐색)를 활용하여 해결할 수 있습니다.

#### 입출력 예시1

- **입력:**
  - `numbers = [1, 1, 1, 1, 1]`
  - `target = 3`
- **출력:**
  - 5

**설명:**
- 다음과 같은 5가지 방법으로 타겟 넘버 3을 만들 수 있습니다:
  - `-1+1+1+1+1 = 3`
  - `+1-1+1+1+1 = 3`
  - `+1+1-1+1+1 = 3`
  - `+1+1+1-1+1 = 3`
  - `+1+1+1+1-1 = 3`

<br>

## 문제 구현 알고리즘

1. **DFS(깊이 우선 탐색) 활용**:
   - 각 숫자마다 더하거나 빼는 두 가지 선택지를 가진 상태에서 모든 경우의 수를 탐색합니다.
   - DFS를 사용하여 재귀적으로 각 단계에서 두 가지 선택(더하기 또는 빼기)을 수행합니다.

2. **초기 설정**:
   - 초기 값으로 `index`를 0으로, `current_sum`을 0으로 설정한 후 DFS를 시작합니다.

3. **재귀적 탐색**:
   - 현재 숫자를 더하는 경우와 빼는 경우를 각각 DFS로 재귀 호출합니다.
   - 모든 숫자를 사용했을 때(`index`가 `numbers.length`와 같을 때), `current_sum`이 `target`과 동일하면 방법의 수를 하나 증가시킵니다.

4. **결과 반환**:
   - DFS 탐색을 통해 얻은 타겟 넘버를 만드는 방법의 수를 반환합니다.

### 예시 데이터의 변화

- **numbers = [1, 1, 1, 1, 1]**
- **target = 3**

1. DFS 탐색 시작:
   - 시작점에서 두 가지 선택지: `+1` 또는 `-1`
   
2. 다음 단계로 이동하면서 계속해서 두 가지 선택지(더하기/빼기)를 가지며 DFS를 수행:
   - 예를 들어, 첫 번째 `1`을 더한 후 두 번째 `1`을 더하거나 빼는 방식으로 탐색합니다.
   
3. DFS 종료 시:
   - 모든 가능한 경우를 탐색한 후, 타겟 넘버를 만들 수 있는 경우의 수를 반환합니다.

4. 최종 계산:
   - `result = 5`를 반환 (예시의 경우).

<br>

## 공부 내용 정리

### DFS (깊이 우선 탐색)

- DFS는 트리나 그래프와 같은 자료구조에서 한 경로를 끝까지 탐색한 후, 다른 경로를 탐색하는 방식으로 동작합니다.
- 이번 문제에서는 DFS를 활용하여 모든 가능한 숫자 조합을 탐색하며 타겟 넘버를 만들 수 있는 경우의 수를 계산했습니다.

<br>

#99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
